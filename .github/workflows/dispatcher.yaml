name: Data Retrieval Dispatcher

# Add permissions at workflow level
permissions:
  issues: write
  contents: read

on:
  issues:
    types: [opened]

jobs:
  label_check:
    name: Check if data retrieval label exists
    runs-on: ubuntu-latest
    outputs:
      should_process: ${{ steps.check.outputs.should_process }}
    steps:
      - name: Check for data retrieval label
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.issue.labels.map(label => label.name);
            const hasDataRetrievalLabel = labels.includes('data retrieval');
            core.setOutput('should_process', hasDataRetrievalLabel);
            core.info(`Has data retrieval label: ${hasDataRetrievalLabel}`);
            return hasDataRetrievalLabel;

  handle_issue:
    name: Extract issue data and prepare for processing
    runs-on: ubuntu-latest
    needs: label_check
    if: needs.label_check.outputs.should_process == 'true'
    outputs:
      receiver_email: ${{ steps.extract.outputs.receiver_email }}
      extracted_link: ${{ steps.extract.outputs.extracted_link }}
      issue_url: ${{ steps.extract.outputs.issue_url }}
    steps:
      - name: Extract information from issue
        id: extract
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            
            // Extract email address
            const emailMatch = issueBody.match(/###\s*Your UC Berkeley Email Address\s*\n\s*([^\n]+@[^\n]+)/i);
            const email = emailMatch ? emailMatch[1].trim() : '';
            
            // Extract DataHub folder link
            const linkMatch = issueBody.match(/###\s*Link to Your Datahub Folder\s*\n\s*(gs:\/\/[^\n]+)/i);
            const link = linkMatch ? linkMatch[1].trim() : '';
            
            // Get issue URL
            const issueUrl = issue.html_url;
            
            // DO NOT mask email here - it needs to be passed to subsequent jobs
            core.info('Email extracted (will be masked after issue processing)');
            core.info(`Extracted link: ${link}`);
            core.info(`Issue URL: ${issueUrl}`);
            
            core.setOutput('receiver_email', email);
            core.setOutput('extracted_link', link);
            core.setOutput('issue_url', issueUrl);

  # DISABLED FOR TESTING - Email sending workflow
  # Uncomment when secrets are configured: GCP_SERVICE_ACCOUNT_KEY, TOKEN_PICKLE
  # process_requests:
  #   name: Process data retrieval request
  #   runs-on: ubuntu-latest
  #   needs: handle_issue
  #   if: needs.handle_issue.outputs.receiver_email != '' && needs.handle_issue.outputs.extracted_link != ''
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4
  #
  #     - name: Set up Python
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: '3.11'
  #
  #     - name: Install dependencies
  #       run: |
  #         pip install google-api-python-client google-auth-oauthlib google-cloud-storage requests
  #
  #     - name: Run data retrieval and email script
  #       env:
  #         RECEIVER_EMAIL: ${{ needs.handle_issue.outputs.receiver_email }}
  #         EXTRACTED_LINK: ${{ needs.handle_issue.outputs.extracted_link }}
  #         ISSUE_URL: ${{ needs.handle_issue.outputs.issue_url }}
  #         GCP_SERVICE_ACCOUNT_KEY: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
  #         TOKEN_PICKLE: ${{ secrets.TOKEN_PICKLE }}
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       run: |
  #         python .github/scripts/sign_url_and_send_emails.py
  #
  #     - name: Close issue after processing
  #       if: success()
  #       uses: actions/github-script@v7
  #       with:
  #         script: |
  #           const issueNumber = context.payload.issue.number;
  #           await github.rest.issues.update({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             issue_number: issueNumber,
  #             state: 'closed'
  #           });

  # TEST MODE - Skip email sending but validate and close issue
  # FERPA compliance (email redaction) is handled by separate workflow after issue closure
  test_validation:
    name: Test - Validate and close issue
    runs-on: ubuntu-latest
    needs: handle_issue
    if: needs.handle_issue.outputs.receiver_email != '' && needs.handle_issue.outputs.extracted_link != ''
    steps:
      - name: Validate extracted data
        run: |
          echo "âœ… Successfully extracted data from issue:"
          echo "  Email: ***"
          echo "  Link: ${{ needs.handle_issue.outputs.extracted_link }}"
          echo "  Issue URL: ${{ needs.handle_issue.outputs.issue_url }}"
          echo ""
          echo "âš ï¸  EMAIL WORKFLOW DISABLED FOR TESTING"
          echo "âš ï¸  Proceeding with issue closure"
          echo "ðŸ“‹ FERPA compliance will be handled automatically after issue closes"

      - name: Comment on issue (TEST MODE)
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;
            const link = '${{ needs.handle_issue.outputs.extracted_link }}';
            
            const comment = `### âš ï¸ Test Mode - Email Workflow Disabled
            
            **Your data retrieval request has been processed (TEST MODE):**
            - ðŸ“§ Email: Will be redacted automatically (FERPA compliance)
            - ðŸ“ Archived file location: \`${link}\`
            
            **Note:** Email sending is currently disabled for testing. In production mode, you would receive an email with signed URLs to download your archived files.
            
            **ðŸ”’ FERPA Compliance:** After this issue is closed, all email addresses will be automatically redacted from the issue body, comments, and GitHub Actions logs by our compliance workflow.
            
            This issue is being automatically closed.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: comment
            });

      - name: Close issue (triggers FERPA compliance workflow)
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              state: 'closed'
            });
            core.info('âœ… Issue closed successfully');
            core.info('ðŸ“‹ FERPA compliance will run in next job');

  # FERPA COMPLIANCE - Runs after issue is closed
  # Separate job for clean separation of concerns for PR purposes
  ferpa_compliance:
    name: FERPA - Redact emails from issue and logs
    runs-on: ubuntu-latest
    needs: test_validation
    if: always()
    permissions:
      issues: write
    
    steps:
      # Step 1: Extract and mask all emails from logs immediately
      - name: Mask Berkeley emails from workflow logs
        id: mask_emails
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            
            core.info('Issue body length: ' + issueBody.length);
            
            // Extract emails from mailto links first
            const mailtoLinkPattern = /\[([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\]\(mailto:\1\)/gi;
            const mailtoPattern = /mailto:([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})/gi;
            
            // Multiple email patterns to catch everything
            const berkeleyEmailRegex = /[A-Za-z0-9._%+-]+@berkeley\.edu/gi;
            const genericEmailRegex1 = /[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/gi;
            const genericEmailRegex2 = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/gi;
            
            // Extract all emails using multiple patterns
            const emails = [];
            [mailtoLinkPattern, mailtoPattern, berkeleyEmailRegex, genericEmailRegex1, genericEmailRegex2].forEach(regex => {
              const matches = issueBody.match(regex);
              if (matches) {
                // For mailto patterns, extract just the email part
                if (regex === mailtoPattern) {
                  matches.forEach(match => {
                    const emailMatch = match.match(/mailto:([^)]+)/);
                    if (emailMatch) emails.push(emailMatch[1]);
                  });
                } else if (regex === mailtoLinkPattern) {
                  matches.forEach(match => {
                    const emailMatch = match.match(/\[([^\]]+)\]/);
                    if (emailMatch) emails.push(emailMatch[1]);
                  });
                } else {
                  emails.push(...matches);
                }
              }
            });
            
            // Get unique emails
            const uniqueEmails = [...new Set(emails)];
            
            core.info(`Found ${uniqueEmails.length} email address(es) to mask`);
            
            if (uniqueEmails.length > 0) {
              // Mask all emails from logs
              uniqueEmails.forEach(email => {
                core.setSecret(email);
                core.info(`Masked: ${email.substring(0, 2)}***@***`);
              });
              
              core.info('âœ… All email addresses masked from workflow logs');
              return true;
            } else {
              core.warning('âš ï¸ No email addresses found to mask');
              core.info('Issue body preview: ' + issueBody.substring(0, 300));
              return false;
            }
      
      # Step 2: Redact emails from issue body
      - name: Redact emails from issue body
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;
            
            // Get current issue
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            core.info('Original issue body length: ' + (issue.body ? issue.body.length : 0));
            
            // Check if already redacted
            if (issue.body && issue.body.includes('[REDACTED FOR FERPA COMPLIANCE]')) {
              core.info('Issue body already contains FERPA redaction - skipping');
              return false;
            }
            
            if (!issue.body) {
              core.info('Issue body is empty - skipping');
              return false;
            }
            
            // Multiple patterns to catch all formats including markdown mailto links
            let redactedBody = issue.body;
            
            // Pattern 1: Markdown mailto links: [email](mailto:email)
            const mailtoLinkPattern = /\[([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\]\(mailto:\1\)/gi;
            redactedBody = redactedBody.replace(mailtoLinkPattern, '[REDACTED FOR FERPA COMPLIANCE]');
            
            // Pattern 2: Any remaining mailto links with different text
            const mailtoPattern = /\[([^\]]+)\]\(mailto:[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\)/gi;
            redactedBody = redactedBody.replace(mailtoPattern, '[REDACTED FOR FERPA COMPLIANCE]');
            
            // Pattern 3: Standard email addresses (most permissive)
            const emailPattern1 = /[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/gi;
            
            // Pattern 4: Email addresses with word boundaries
            const emailPattern2 = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/gi;
            
            // Pattern 5: Berkeley emails specifically
            const berkeleyPattern = /[A-Za-z0-9._%+-]+@berkeley\.edu/gi;
            
            // Apply remaining patterns to catch any non-markdown emails
            const emails = [];
            [emailPattern1, emailPattern2, berkeleyPattern].forEach(pattern => {
              const matches = issue.body.match(pattern);
              if (matches) {
                emails.push(...matches);
              }
            });
            
            // Get unique emails
            const uniqueEmails = [...new Set(emails)];
            
            if (uniqueEmails.length > 0) {
              core.info(`Found ${uniqueEmails.length} email(s) to redact: ${uniqueEmails.map(e => e.substring(0, 3) + '***').join(', ')}`);
              
              // Replace each unique email
              uniqueEmails.forEach(email => {
                // Escape special regex characters in the email for safe replacement
                const escapedEmail = email.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const replaceRegex = new RegExp(escapedEmail, 'gi');
                redactedBody = redactedBody.replace(replaceRegex, '[REDACTED FOR FERPA COMPLIANCE]');
              });
            }
            
            if (redactedBody !== issue.body) {
              core.info('Redacted body preview: ' + redactedBody.substring(0, 200));
              
              // Update issue with redacted body
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: redactedBody
              });
              
              core.info('âœ… Successfully redacted email addresses from issue body');
              return true;
            } else {
              core.info('âš ï¸ No email addresses found in issue body');
              core.info('Issue body preview: ' + issue.body.substring(0, 300));
              return false;
            }
      
      # Step 3: Redact emails from all issue comments
      - name: Redact emails from issue comments
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;
            
            // Get all comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            core.info(`Found ${comments.length} comment(s) to check`);
            
            // Multiple email patterns including markdown mailto links
            const mailtoLinkPattern = /\[([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\]\(mailto:\1\)/gi;
            const mailtoPattern = /\[([^\]]+)\]\(mailto:[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\)/gi;
            const emailPattern1 = /[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/gi;
            const emailPattern2 = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/gi;
            const berkeleyPattern = /[A-Za-z0-9._%+-]+@berkeley\.edu/gi;
            
            let redactedCount = 0;
            
            for (const comment of comments) {
              // Skip if this is the FERPA compliance notice itself
              if (comment.body.includes('ðŸ”’ FERPA Compliance Notice')) {
                core.info(`Skipping compliance notice comment #${comment.id}`);
                continue;
              }
              
              // Skip if already redacted
              if (comment.body.includes('[REDACTED FOR FERPA COMPLIANCE]')) {
                core.info(`Comment #${comment.id} already redacted - skipping`);
                continue;
              }
              
              // Find all emails in this comment
              const emails = [];
              [mailtoLinkPattern, mailtoPattern, emailPattern1, emailPattern2, berkeleyPattern].forEach(pattern => {
                const matches = comment.body.match(pattern);
                if (matches) {
                  // For mailto patterns, extract just the email part
                  if (pattern === mailtoPattern) {
                    matches.forEach(match => {
                      const emailMatch = match.match(/mailto:([^)]+)/);
                      if (emailMatch) emails.push(emailMatch[1]);
                    });
                  } else if (pattern === mailtoLinkPattern) {
                    matches.forEach(match => {
                      const emailMatch = match.match(/\[([^\]]+)\]/);
                      if (emailMatch) emails.push(emailMatch[1]);
                    });
                  } else {
                    emails.push(...matches);
                  }
                }
              });
              
              const uniqueEmails = [...new Set(emails)];
              
              if (uniqueEmails.length > 0) {
                core.info(`Found ${uniqueEmails.length} email(s) in comment #${comment.id}`);
                
                let redactedBody = comment.body;
                
                // First remove mailto links
                redactedBody = redactedBody.replace(mailtoLinkPattern, '[REDACTED FOR FERPA COMPLIANCE]');
                redactedBody = redactedBody.replace(mailtoPattern, '[REDACTED FOR FERPA COMPLIANCE]');
                
                // Then remove any remaining plain emails
                uniqueEmails.forEach(email => {
                  const escapedEmail = email.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                  const replaceRegex = new RegExp(escapedEmail, 'gi');
                  redactedBody = redactedBody.replace(replaceRegex, '[REDACTED FOR FERPA COMPLIANCE]');
                });
                
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: comment.id,
                  body: redactedBody
                });
                redactedCount++;
              }
            }
            
            if (redactedCount > 0) {
              core.info(`âœ… Successfully redacted email addresses from ${redactedCount} comment(s)`);
            } else {
              core.info('No email addresses found in comments');
            }
      
      # Step 4: Add FERPA compliance notice to issue
      - name: Add FERPA compliance notice
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;
            
            // Check if notice already exists
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const noticeExists = comments.some(comment => 
              comment.body.includes('ðŸ”’ FERPA Compliance Notice')
            );
            
            if (noticeExists) {
              core.info('FERPA compliance notice already posted - skipping');
              return;
            }
            
            // Add compliance notice
            const noticeBody = [
              'ðŸ”’ **FERPA Compliance Notice**',
              '',
              'All email addresses have been automatically redacted from this issue and its comments to comply with the Family Educational Rights and Privacy Act (FERPA).'
            ].join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: noticeBody
            });
            
            core.info('âœ… FERPA compliance notice posted to issue');
