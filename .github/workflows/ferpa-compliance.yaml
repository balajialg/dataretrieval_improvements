name: FERPA Compliance - Email Redaction (Standalone Version)

# âš ï¸ IMPORTANT LIMITATION âš ï¸
# This standalone workflow will NOT be triggered when dispatcher.yaml closes issues
# because GitHub Actions prevents workflows from triggering other workflows when
# using the default GITHUB_TOKEN (security feature to prevent infinite loops).
#
# SOLUTIONS:
# 1. Use this workflow with a Personal Access Token (PAT) in dispatcher.yaml
# 2. Use the combined version in dispatcher.yaml (RECOMMENDED - currently active)
# 3. Manually trigger this workflow after issues are closed
#
# This file is kept for reference and alternative implementation approaches.
# The active FERPA compliance logic is in dispatcher.yaml as a separate job.

permissions:
  issues: write
  contents: read

on:
  # This trigger works, but won't fire when dispatcher.yaml closes issues
  issues:
    types: [closed]
  # Alternative: Allow manual workflow dispatch for testing
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to redact emails from'
        required: true
        type: number

jobs:
  redact_emails:
    name: Redact Berkeley emails for FERPA compliance
    runs-on: ubuntu-latest
    # Only process issues with 'data retrieval' label (or when manually dispatched)
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'data retrieval'))
    
    steps:
      # Step 1: Get issue number (from event or input)
      - name: Determine issue number
        id: get_issue
        uses: actions/github-script@v7
        with:
          script: |
            let issueNumber;
            if (context.eventName === 'workflow_dispatch') {
              issueNumber = context.payload.inputs.issue_number;
              core.info(`Manual dispatch for issue #${issueNumber}`);
            } else {
              issueNumber = context.payload.issue.number;
              core.info(`Triggered by issue closure #${issueNumber}`);
            }
            core.setOutput('issue_number', issueNumber);
            return issueNumber;
      
      # Step 2: Extract and mask all emails from logs immediately
      - name: Mask Berkeley emails from workflow logs
        id: mask_emails
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.get_issue.outputs.issue_number }};
            
            // Get the issue
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const issueBody = issue.body || '';
            
            core.info('Issue body length: ' + issueBody.length);
            
            // Extract emails from mailto links first
            const mailtoLinkPattern = /\[([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\]\(mailto:\1\)/gi;
            const mailtoPattern = /mailto:([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})/gi;
            
            // Multiple email patterns to catch everything
            const berkeleyEmailRegex = /[A-Za-z0-9._%+-]+@berkeley\.edu/gi;
            const genericEmailRegex1 = /[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/gi;
            const genericEmailRegex2 = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/gi;
            
            // Extract all emails using multiple patterns
            const emails = [];
            [mailtoLinkPattern, mailtoPattern, berkeleyEmailRegex, genericEmailRegex1, genericEmailRegex2].forEach(regex => {
              const matches = issueBody.match(regex);
              if (matches) {
                // For mailto patterns, extract just the email part
                if (regex === mailtoPattern) {
                  matches.forEach(match => {
                    const emailMatch = match.match(/mailto:([^)]+)/);
                    if (emailMatch) emails.push(emailMatch[1]);
                  });
                } else if (regex === mailtoLinkPattern) {
                  matches.forEach(match => {
                    const emailMatch = match.match(/\[([^\]]+)\]/);
                    if (emailMatch) emails.push(emailMatch[1]);
                  });
                } else {
                  emails.push(...matches);
                }
              }
            });
            
            // Get unique emails
            const uniqueEmails = [...new Set(emails)];
            
            core.info(`Found ${uniqueEmails.length} email address(es) to mask`);
            
            if (uniqueEmails.length > 0) {
              // Mask all emails from logs
              uniqueEmails.forEach(email => {
                core.setSecret(email);
                core.info(`Masked: ${email.substring(0, 2)}***@***`);
              });
              
              core.info('âœ… All email addresses masked from workflow logs');
              return true;
            } else {
              core.warning('âš ï¸ No email addresses found to mask');
              core.info('Issue body preview: ' + issueBody.substring(0, 300));
              return false;
            }
      
      # Step 3: Redact emails from issue body
      - name: Redact emails from issue body
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.get_issue.outputs.issue_number }};
            
            // Get current issue
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            core.info('Original issue body length: ' + (issue.body ? issue.body.length : 0));
            
            // Check if already redacted
            if (issue.body && issue.body.includes('[REDACTED FOR FERPA COMPLIANCE]')) {
              core.info('Issue body already contains FERPA redaction - skipping');
              return false;
            }
            
            if (!issue.body) {
              core.info('Issue body is empty - skipping');
              return false;
            }
            
            // Multiple patterns to catch all formats including markdown mailto links
            let redactedBody = issue.body;
            
            // Pattern 1: Markdown mailto links: [email](mailto:email)
            const mailtoLinkPattern = /\[([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\]\(mailto:\1\)/gi;
            redactedBody = redactedBody.replace(mailtoLinkPattern, '[REDACTED FOR FERPA COMPLIANCE]');
            
            // Pattern 2: Any remaining mailto links with different text
            const mailtoPattern = /\[([^\]]+)\]\(mailto:[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\)/gi;
            redactedBody = redactedBody.replace(mailtoPattern, '[REDACTED FOR FERPA COMPLIANCE]');
            
            // Pattern 3: Standard email addresses (most permissive)
            const emailPattern1 = /[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/gi;
            
            // Pattern 4: Email addresses with word boundaries
            const emailPattern2 = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/gi;
            
            // Pattern 5: Berkeley emails specifically
            const berkeleyPattern = /[A-Za-z0-9._%+-]+@berkeley\.edu/gi;
            
            // Apply remaining patterns to catch any non-markdown emails
            const emails = [];
            [emailPattern1, emailPattern2, berkeleyPattern].forEach(pattern => {
              const matches = issue.body.match(pattern);
              if (matches) {
                emails.push(...matches);
              }
            });
            
            // Get unique emails
            const uniqueEmails = [...new Set(emails)];
            
            if (uniqueEmails.length > 0) {
              core.info(`Found ${uniqueEmails.length} email(s) to redact: ${uniqueEmails.map(e => e.substring(0, 3) + '***').join(', ')}`);
              
              // Replace each unique email
              uniqueEmails.forEach(email => {
                // Escape special regex characters in the email for safe replacement
                const escapedEmail = email.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const replaceRegex = new RegExp(escapedEmail, 'gi');
                redactedBody = redactedBody.replace(replaceRegex, '[REDACTED FOR FERPA COMPLIANCE]');
              });
            }
            
            if (redactedBody !== issue.body) {
              core.info('Redacted body preview: ' + redactedBody.substring(0, 200));
              
              // Update issue with redacted body
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: redactedBody
              });
              
              core.info('âœ… Successfully redacted email addresses from issue body');
              return true;
            } else {
              core.info('âš ï¸ No email addresses found in issue body');
              core.info('Issue body preview: ' + issue.body.substring(0, 300));
              return false;
            }
      
      # Step 4: Redact emails from all issue comments
      - name: Redact emails from issue comments
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.get_issue.outputs.issue_number }};
            
            // Get all comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            core.info(`Found ${comments.length} comment(s) to check`);
            
            // Multiple email patterns including markdown mailto links
            const mailtoLinkPattern = /\[([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\]\(mailto:\1\)/gi;
            const mailtoPattern = /\[([^\]]+)\]\(mailto:[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\)/gi;
            const emailPattern1 = /[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/gi;
            const emailPattern2 = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/gi;
            const berkeleyPattern = /[A-Za-z0-9._%+-]+@berkeley\.edu/gi;
            
            let redactedCount = 0;
            
            for (const comment of comments) {
              // Skip if this is the FERPA compliance notice itself
              if (comment.body.includes('ðŸ”’ FERPA Compliance Notice')) {
                core.info(`Skipping compliance notice comment #${comment.id}`);
                continue;
              }
              
              // Skip if already redacted
              if (comment.body.includes('[REDACTED FOR FERPA COMPLIANCE]')) {
                core.info(`Comment #${comment.id} already redacted - skipping`);
                continue;
              }
              
              // Find all emails in this comment
              const emails = [];
              [mailtoLinkPattern, mailtoPattern, emailPattern1, emailPattern2, berkeleyPattern].forEach(pattern => {
                const matches = comment.body.match(pattern);
                if (matches) {
                  // For mailto patterns, extract just the email part
                  if (pattern === mailtoPattern) {
                    matches.forEach(match => {
                      const emailMatch = match.match(/mailto:([^)]+)/);
                      if (emailMatch) emails.push(emailMatch[1]);
                    });
                  } else if (pattern === mailtoLinkPattern) {
                    matches.forEach(match => {
                      const emailMatch = match.match(/\[([^\]]+)\]/);
                      if (emailMatch) emails.push(emailMatch[1]);
                    });
                  } else {
                    emails.push(...matches);
                  }
                }
              });
              
              const uniqueEmails = [...new Set(emails)];
              
              if (uniqueEmails.length > 0) {
                core.info(`Found ${uniqueEmails.length} email(s) in comment #${comment.id}`);
                
                let redactedBody = comment.body;
                
                // First remove mailto links
                redactedBody = redactedBody.replace(mailtoLinkPattern, '[REDACTED FOR FERPA COMPLIANCE]');
                redactedBody = redactedBody.replace(mailtoPattern, '[REDACTED FOR FERPA COMPLIANCE]');
                
                // Then remove any remaining plain emails
                uniqueEmails.forEach(email => {
                  const escapedEmail = email.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                  const replaceRegex = new RegExp(escapedEmail, 'gi');
                  redactedBody = redactedBody.replace(replaceRegex, '[REDACTED FOR FERPA COMPLIANCE]');
                });
                
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: comment.id,
                  body: redactedBody
                });
                redactedCount++;
              }
            }
            
            if (redactedCount > 0) {
              core.info(`âœ… Successfully redacted email addresses from ${redactedCount} comment(s)`);
            } else {
              core.info('No email addresses found in comments');
            }
      
      # Step 5: Add FERPA compliance notice to issue
      - name: Add FERPA compliance notice
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.get_issue.outputs.issue_number }};
            
            // Check if notice already exists
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const noticeExists = comments.some(comment => 
              comment.body.includes('ðŸ”’ FERPA Compliance Notice')
            );
            
            if (noticeExists) {
              core.info('FERPA compliance notice already posted - skipping');
              return;
            }
            
            // Add compliance notice
            const noticeBody = [
              'ðŸ”’ **FERPA Compliance Notice**',
              '',
              'All email addresses have been automatically redacted from this issue and its comments to comply with the Family Educational Rights and Privacy Act (FERPA).'
            ].join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: noticeBody
            });
            
            core.info('âœ… FERPA compliance notice posted to issue');
